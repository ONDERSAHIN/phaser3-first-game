/* Copyright (c) 2017 MIT 6.813/6.831 course staff, all rights reserved.
 * Redistribution of original or derived work requires permission of course staff.
 */

/*
*
* This class implements the rules of Candy Crush.
*
*/

import Board from "@/game/core/old/board.class";

class Rules {
    scoring = false;
    board = new Board(0);

    constructor(board) {
        if (board instanceof Board) {
            this.board = board;
        }
    }

    prepareNewGame() {
        this.scoring = false;
        while (true) {
            this.populateBoard()
            let crushable = this.getCandyCrushes();
            if (crushable.length === 0) break;
            this.removeCrushes(crushable);
        }
        this.scoring = true;
    }


    /*
    *
    *  Returns true if flipping fromCandy with the candy in the direction
    *  specified (['up', 'down', 'left', 'right']) is valid
    *  (according to the rules), else returns false.
    *
    */
    isMoveTypeValid(fromCandy, direction) {
        return this.numberCandiesCrushedByMove(fromCandy, direction) > 0;
    }

    /*
    *
    *  Returns a list of ALL candy crushes on the board. A candy crush is
    *  a list of three or more candies in a single row or column that have
    *  the same color. Each crush is provided as a list of the candies being
    *  crushed, resulting in a list of lists. The output of this method should
    *  be passed directly into this.removeCrushes to remove candy crushes.
    *
    */
    getCandyCrushes(swap) {
        // Implemented with a (not fully optimized) Tarjan's union-find algorithm.
        // Implementation of the classic union-find algorithm (unoptimized).
        // Allows any string keys to be unioned into a set of disjoint sets.
        // https://en.wikipedia.org/wiki/Disjoint-set_data_structure
        let unioned = {};
        let sizes = {};
        let row, col;

        // Finds the set representative for the set that this key is a member of.
        function find(key) {
            let parent = unioned[key];
            if (parent == null) return key;
            parent = find(parent);
            unioned[key] = parent;  // Path compression
            return parent;
        }

        // The size of the set represented by 'found'; assume 1 if not stored.
        function size(found) {
            return sizes[found] || 1;
        }

        // Ennsures that the two keys are in the same set, joining if needed.
        function union(key1, key2) {
            let p1 = find(key1), p2 = find(key2);
            if (p1 === p2) return p1;
            // Do not bother implementing union by rank.  This is pretty fast too.
            // n.b., http://stackoverflow.com/a/2326676/265298
            unioned[p2] = p1;
            sizes[p1] = size(p1) + size(p2);
            delete sizes[p2];
        }

        // Get strips of length 3.
        let vert = this.findColorStrips(true, swap);
        let horiz = this.findColorStrips(false, swap);
        let sets = vert.concat(horiz);

        // Execute union of all the strips, possibly joining
        // horizontal and vertical strips that intersect.
        for (let j = 0; j < sets.length; j++) {
            let set = sets[j];
            for (let k = 1; k < set.length; k++) {
                union(set[0].id, set[k].id)
            }
        }

        // Pass 2: list out resulting sets of minSize or larger.
        let results = {}
        for (row = 0; row < this.board.boardSize; row++) {
            for (col = 0; col < this.board.boardSize; col++) {
                let candy = this.board.getCandyAt(row, col);
                if (candy) {
                    let p = find(candy.id);
                    if (size(p) >= 3) {
                        if (!(p in results)) results[p] = [];
                        results[p].push(candy);
                    }
                }
            }
        }
        // Pass 3: Return results as a list of list of candies.
        let list = [];
        for (let key in results) {
            list.push(results[key]);
        }
        return list;
    }


    /*
    *
    *   Deletes all the candies in setOfSetsOfCrushes (which can be
    *   generated by getCandyCrushes or by getCandiesToCrushGivenMove.)
    *   Does not shift candies down at all. Updates the score accordingly.
    *
    */
    removeCrushes(setOfSetsOfCrushes) {
        for (let j = 0; j < setOfSetsOfCrushes.length; j++) {
            let set = setOfSetsOfCrushes[j];
            for (let k = 0; k < set.length; k++) {
                if (this.scoring) this.board.incrementScore(set[k], set[k].row, set[k].col);
                this.board.remove(set[k]);
            }
        }
    }

    /*
    *
    *  Moves candies down as far as there are empty spaces. Issues calls to
    *  board.moveTo, which generate "move" events to listen for. If there
    *  are holes created by moving the candies down, populates the holes
    *  with random candies, and issues "add" events for these candies.
    *
    */
    moveCandiesDown() {
        // Collapse each column
        for (let col = 0; col < this.board.getSize(); col++) {
            let emptyRow = null;
            // In each column, scan for the bottom most empty row
            for (emptyRow = this.board.getSize() - 1; emptyRow >= 0; emptyRow--) {
                if (this.board.getCandyAt(emptyRow, col) == null) {
                    break;
                }
            }
            // Then shift any nonempty rows up
            for (let row = emptyRow - 1; row >= 0; row--) {
                let candy = this.board.getCandyAt(row, col);
                if (candy != null) {
                    this.board.moveTo(candy, emptyRow, col);
                    emptyRow--;
                }
            }

            for (let spawnRow = -1; emptyRow >= 0; emptyRow--, spawnRow--) {
                // We report spawnRow as the (negative) position where
                // the candy "would have" started to fall into place.
                this.board.addRandomCandy(emptyRow, col, spawnRow, col);
            }

        }
    }


    /*
    *
    *  If there is a valid move, returns an object with two properties:
    *  candy: a Candy that can be moved
    *  direction: the direction that it can be moved.
    *  If there are no valid moves, returns null.  The move is selected
    *  randomly from the available moves, favoring moves with smaller crushes.
    *
    */
    getRandomValidMove() {
        let directions = ['up', 'down', 'left', 'right'];
        let validMovesThreeCrush = [];
        let validMovesMoreThanThreeCrush = [];

        // For each cell in the board, check to see if moving it in
        // any of the four directions would result in a crush
        // if so, add it to the appropriate list (validMoves_threeCrush for
        // crushes of size 3, validMoves_moreThanThreeCrush for crushes
        // larger than 3)
        for (let row = 0; row < this.board.getSize(); row++) {
            for (let col = 0; col < this.board.getSize(); col++) {
                let fromCandy = this.board.getCandyAt(row, col);
                if (!fromCandy) continue;
                for (let i = 0; i < 4; i++) {
                    let direction = directions[i];
                    let numCandiesCrushed = this.numberCandiesCrushedByMove(fromCandy, direction);
                    if (numCandiesCrushed === 3) {
                        validMovesThreeCrush.push({candy: fromCandy, direction: direction});
                    } else if (numCandiesCrushed > 3) {
                        validMovesMoreThanThreeCrush.push(
                            {candy: fromCandy, direction: direction});
                    }
                }
            }
        }
        // if there are three-crushes possible, prioritize these
        let searchArray = validMovesThreeCrush.length ? validMovesThreeCrush :
            validMovesMoreThanThreeCrush;
        // If there are no valid moves, return null.
        if (searchArray.length === 0) return null;
        // select a random crush from among the crushes found
        return searchArray[Math.floor(Math.random() * searchArray.length)];
    }


    ////////////////////////////////////////////////
    // USEFUL FOR DEBUGGING
    //
    //

    /*
    *
    *  Specify a board configuration by passing in a boardSpec. The format
    *  of boardSpec is a list of strings, one sequence for each row. In each
    *  string, there must be boardSize characters, where each character should
    *  be the first letter of the color for that square. For example, a boardSpec
    *  that specifies an 8x8 board with alternating columns of red and orange would have
    *  a boardSpec of:
    *  ['rorororo',
    *  'rorororo',
    *  'rorororo',
    *  'rorororo',
    *  'rorororo',
    *  'rorororo',
    *  'rorororo',
    *  'rorororo']
    *
    */
    createSpecifiedBoard(boardSpec) {

        let color_dict = {'r': 'red', 'o': 'orange', 'y': 'yellow', 'g': 'green', 'b': 'blue', 'p': 'purple','d':'darkred','s':'silver','l':'luna'}

        let numChars = 0;

        boardSpec.map(function (i) {
            return numChars += i.length
        });
        if (boardSpec.length !== board.boardSize || numChars !== Math.pow(board.boardSize, 2)) {
            console.warn("boardSpec must be of dimensions boardSize x boardSize to populate board");
            return;
        }

        for (let col = 0; col < this.board.getSize(); col++) {
            for (let row = 0; row < this.board.getSize(); row++) {
                if (this.board.getCandyAt(row, col) == null) {
                    let color = color_dict[boardSpec[row].charAt(col)];
                    this.board.addCandy(color, row, col);
                }
            }
        }

    }


    ////////////////////////////////////////////////
    // Private methods
    //
    // You likely do NOT need to call these methods
    //


    /*
    *  Helper method to rules.prepareNewGame
    *  Called when a new game is created. Fills all the empty positions on
    *  the board with random-colored candies.
    *
    */
    populateBoard() {
        for (let col = 0; col < this.board.getSize(); col++) {
            for (let row = 0; row < this.board.getSize(); row++) {
                // Check the empty candy position (hole), fill with new candy
                if (this.board.getCandyAt(row, col) == null) {
                    this.board.addRandomCandy(row, col);
                }
            }
        }
    }


    /*
    *
    *  Helper method for rules.isMoveTypeValid
    *  Returns the number of candies that would be crushed if the candy
    *  provided by fromCandy were to be flipped in the direction
    *  specified (['up', 'down', 'left', 'right'])
    *
    *  If this move is not valid (based on the game rules), then 0 is returned
    *
    */
    numberCandiesCrushedByMove(fromCandy, direction) {
        return this.getCandiesToCrushGivenMove(fromCandy, direction).length;
    }

    /*
    *
    *  Helper method for rules.numberCandiesCrushedByMove
    *  Returns a list of candies that would be "crushed" (i.e. removed) if
    *  fromCandy were to be moved in the direction specified by direction (['up',
    *  'down', 'left', 'right'])
    *  If move would result in no crushed candies, an empty list is returned.
    *
    */
    getCandiesToCrushGivenMove(fromCandy, direction) {
        let toCandy = this.board.getCandyInDirection(fromCandy, direction);
        if (!toCandy || toCandy.color === fromCandy.color) {
            return [];
        }
        let swap = [fromCandy, toCandy];
        let crushable = this.getCandyCrushes(swap);
        //console.log(crushable);
        // Only return crushable groups that involve the swapped candies.
        // If the board has incompletely-resolved crushes, there can be
        // many crushable candies that are not touching the swapped ones.
        let connected = crushable.filter(function (set) {
            for (let k = 0; k < swap.length; k++) {
                if (set.indexOf(swap[k]) >= 0) return true;
            }
            return false;
        });
        //console.log(connected);
        //console.log([].concat.apply([], connected));
        return [].concat.apply([], connected); //flatten nested lists
    }


    /*
    *
    *  Helper Method for rules.getCandyCrushes
    *  Returns a set of sets of all the same-color candy strips of length
    *  at least 3 on the board.  If 'vertical' is set to true, looks only for
    *  vertical strips; otherwise only horizontal ones. If the 'swap' array
    *  is passed, then every even-indexed candy in the array is considered
    *  swapped with every odd-indexed candy in the array.
    *
    */

    findColorStrips(vertical, swap) {
         let getAt = (x, y) => {
            // Retrieve the candy at a row and column (depending on vertical)
            let result = vertical ? this.board.getCandyAt(y, x) : this.board.getCandyAt(x, y);
            if (swap) {
                // If the result candy is in the 'swap' array, then swap the
                // result with its adjacent pair.
                let index = swap.indexOf(result);
                if (index >= 0) return swap[index ^ 1];
            }
            return result;
        };
        let result = [];
        for (let j = 0; j < this.board.getSize(); j++) {
            for (let h, k = 0; k < this.board.getSize(); k = h) {
                // Scan for rows of same-colored candy starting at k
                let firstCandy = getAt(j, k);
                h = k + 1;
                if (!firstCandy) continue;
                let candies = [firstCandy];
                for (; h < this.board.getSize(); h++) {
                    let lastCandy = getAt(j, h);
                    if (!lastCandy || lastCandy.color !== firstCandy.color) break;
                    candies.push(lastCandy);
                }
                // If there are at least 3 candies in a row, remember the set.
                if (candies.length >= 3){
                    result.push(candies);
                } 
            }
        }
        return result;
    }


}

export default Rules;